import { runInjectionExploit } from '../src/exploitRunner';
import { runPrototypePollutionExploit } from '../src/exploitRunner';
import { runPathTraversalExploit } from '../src/exploitRunner';

describe('runInjectionExploit', () => {
  it('returns ExploitResult when code writes a .txt file', () => {
    const code = `require('fs').writeFileSync('payload.txt', 'injected');`;
    const result = runInjectionExploit(code);

    expect(result.type).toBe('ExploitResult');
  });

  it('returns RuntimeErrorResult for crashing code', () => {
    const code = `throw new Error("boom")`;
    const result = runInjectionExploit(code);

    expect(result.type).toBe('RuntimeErrorResult');
  });
 
  it('returns UnsuccessfulRun if nothing happens', () => {
    const code = `console.log("no-op");`;
    const result = runInjectionExploit(code);

    expect(result.type).toBe('UnsuccessfulRunResult');
  });
});


describe('runPrototypePollutionExploit', () => {
     it('detects simple key pollution', () => {
        const code = `Object.prototype.polluted = true;`;
        const result = runPrototypePollutionExploit(code);
        expect(result.type).toBe('ExploitResult');
    });

    it('detects simple key pollution when execute by a required function', () => {
        const code = `require("/home/gc/Desktop/MEIC/ano-2/tese/explode-js_ng/llm-interaction/tests/data/prototype-pollution.js")`;
        const result = runPrototypePollutionExploit(code);
        console.log(result);
        expect(result.type).toBe('ExploitResult');
    });

   
    it('detects modification of existing primitive prototype key', () => {
        const code = `Object.prototype.toString = 'polluted';`;
        const result = runPrototypePollutionExploit(code);
        expect(result.type).toBe('ExploitResult');
    });

    it('ignores non-polluting code', () => {
        const code = `console.log("no pollution here");`;
        const result = runPrototypePollutionExploit(code);
        expect(result.type).toBe('UnsuccessfulRunResult');
    });

    it('returns RuntimeErrorResult on thrown error', () => {
        const code = `throw new Error("boom");`;
        const result = runPrototypePollutionExploit(code);
        expect(result.type).toBe('RuntimeErrorResult');
    });
 
    it('detects multiple pollutions at once', () => {
        const code = `
            Object.prototype.a = "A";
            Object.prototype.b = "B";
            Object.prototype.c = "C";
        `;
        const result = runPrototypePollutionExploit(code);
        expect(result.type).toBe('ExploitResult');
    });

    it('cleans up correctly between executions', () => {
        const pollutionCode = `Object.prototype.p = "polluted";`;
        const cleanCode = `if ("p" in Object.prototype) throw new Error("Residual");`;

        const result1 = runPrototypePollutionExploit(pollutionCode);
        expect(result1.type).toBe('ExploitResult');

        const result2 = runPrototypePollutionExploit(cleanCode);
        expect(result2.type).toBe('UnsuccessfulRunResult');
    });
});



describe('runPathTraversalExploit', () => {
    it('returns ExploitResult when fs writes outside allowed dir', () => {
        const code = `fs.writeFileSync('../traverse.txt', 'pwned');`;
        const result = runPathTraversalExploit(code);

        expect(result.type).toBe('ExploitResult');
    });

    it('returns ExploitResult when a required function writes outside allowed dir', () => {
        const code = `require("/home/gc/Desktop/MEIC/ano-2/tese/explode-js_ng/llm-interaction/tests/data/path-traversal.js")();`;
        const result = runPathTraversalExploit(code);
        console.log(result);

        expect(result.type).toBe('ExploitResult');
    });

    it('returns RuntimeErrorResult for crashing code', () => {
        const code = `throw new Error("boom")`;
        const result = runPathTraversalExploit(code);

        expect(result.type).toBe('RuntimeErrorResult');
    });
    it('returns ExploitResult when reading a file outside uploads dir', () => {
        const code = `fs.readFileSync('/../../../../../../../../../../../../../../../etc/passwd', 'utf8');`;
        const result = runPathTraversalExploit(code);

        expect(result.type).toBe('ExploitResult');
    });
 });

