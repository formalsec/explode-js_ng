// exploitRunner.ts

import fs from 'fs';
import path from 'path';
import os from 'os';
import vm from 'vm';
import {
    Result,
    buildExploitResult,
    buildSyntaxErrorResult,
    buildRuntimeErrorResult,
    buildUnsuccessfulRun,
} from './results';

/** Helper to list all files in a directory */
function listFiles(dir: string): Set<string> {
    return new Set(fs.readdirSync(dir));
}

/** Helper to list all keys on Object.prototype */
function getPrototypeKeys(): Set<string | symbol> {
    return new Set(Reflect.ownKeys(Object.prototype));
}

/** Clean up Object.prototype by deleting polluted properties */
function restoreObjectPrototype(original: Record<string | symbol, any>): void {
    const currentKeys = Reflect.ownKeys(Object.prototype);

    // Delete unexpected keys
    for (const key of currentKeys) {
        if (!(key in original)) {
            delete (Object.prototype as any)[key];
        }
    }

    // Restore missing original properties
    for (const [key, value] of Object.entries(original)) {
        if (!(key in Object.prototype)) {
            (Object.prototype as any)[key] = value;
        }
    }
}

/** Run a Code/Command Injection exploit and detect filesystem changes */
export function runInjectionExploit(exploitCode: string): Result {
    
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'exploit-test-'));
    process.chdir(tmpDir);

    const before = listFiles(tmpDir);

    const context = vm.createContext({ console, require });

    try {
        const script = new vm.Script(`try { ${exploitCode} } catch (e) { console.error(e); }`);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = listFiles(tmpDir);
    const newFiles = [...after].filter(x => !before.has(x));

    if (newFiles.length > 0) {
        return buildExploitResult(exploitCode, `New files created: ${newFiles.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Prototype Pollution exploit and detect new prototype properties */
export function runPrototypePollutionExploit(exploitCode: string): Result {
    
    const originalPrototype = Object.create(null);
    for (const key of Reflect.ownKeys(Object.prototype)) {
        (originalPrototype as any)[key] = (Object.prototype as any)[key];
    }

    const before = getPrototypeKeys();

    const context = vm.createContext({ console, require });

    try {
        const script = new vm.Script(`try { ${exploitCode} } catch (e) { console.error(e); }`);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = getPrototypeKeys();
    const newProps = [...after].filter(x => !before.has(x));

    restoreObjectPrototype(originalPrototype);

    if (newProps.length > 0) {
        return buildExploitResult(exploitCode, `New prototype properties added: ${newProps.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}
