// exploitRunner.ts

import fs from 'fs';
import path from 'path';
import os from 'os';
import vm from 'vm';
import {
    Result,
    buildExploitResult,
    buildSyntaxErrorResult,
    buildRuntimeErrorResult,
    buildUnsuccessfulRun,
} from './results';

/** Helper to list all files in a directory */
function listFiles(dir: string): Set<string> {
    return new Set(fs.readdirSync(dir));
}

/** Helper to list all keys on Object.prototype */
function getPrototypeKeys(): Set<string | symbol> {
    return new Set(Reflect.ownKeys(Object.prototype));
}

/** Clean up Object.prototype by deleting polluted properties */
function restoreObjectPrototype(original: Record<string | symbol, any>): void {
    const currentKeys = Reflect.ownKeys(Object.prototype);

    // Delete unexpected keys
    for (const key of currentKeys) {
        if (!(key in original)) {
            delete (Object.prototype as any)[key];
        }
    }

    // Restore missing original properties
    for (const [key, value] of Object.entries(original)) {
        if (!(key in Object.prototype)) {
            (Object.prototype as any)[key] = value;
        }
    }
}

/** Run a Code/Command Injection exploit and detect filesystem changes */
export function runInjectionExploit(exploitCode: string): Result {
    
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'exploit-test-'));
    process.chdir(tmpDir);

    const before = listFiles(tmpDir);

    const context = vm.createContext({ console, require });

    try {
        const script = new vm.Script(exploitCode);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(exploitCode, e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = listFiles(tmpDir);
    const newFiles = [...after].filter(x => !before.has(x));

    if (newFiles.length > 0) {
        return buildExploitResult(exploitCode, `New files created: ${newFiles.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Prototype Pollution exploit and detect new prototype properties */
export function runPrototypePollutionExploit(exploitCode: string): Result {
    
    const originalPrototype = Object.create(null);
    for (const key of Reflect.ownKeys(Object.prototype)) {
        (originalPrototype as any)[key] = (Object.prototype as any)[key];
    }

    const before = getPrototypeKeys();

    const context = vm.createContext({ console, require });

    try {
        const script = new vm.Script(exploitCode);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(exploitCode, e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = getPrototypeKeys();
    const newProps = [...after].filter(x => !before.has(x));

    restoreObjectPrototype(originalPrototype);

    if (newProps.length > 0) {
        return buildExploitResult(exploitCode, `New prototype properties added: ${newProps.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Path Traversal exploit and detect successful traversals */
function listFilesRecursively(baseDir: string): Set<string> {
  const files = new Set<string>();
  function walk(dir: string) {
    for (const file of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        walk(fullPath);
      } else {
        files.add(path.relative(baseDir, fullPath));
      }
    }
  }
  walk(baseDir);
  return files;
}

function setupTraversalEnvironment(): { baseDir: string, uploadsDir: string } {
  const baseDir = fs.mkdtempSync(path.join(os.tmpdir(), 'path-traversal-test-'));
  const uploadsDir = path.join(baseDir, 'uploads');
  fs.mkdirSync(uploadsDir);
  return { baseDir, uploadsDir };
}

function createFsSpy(logs: string[]): any {
  return {
    ...fs,
    readFileSync: (filePath: string, ...args: any[]) => {
      logs.push(`READ: ${filePath}`);
      return fs.readFileSync(filePath, ...args);
    },
    writeFileSync: (filePath: string, data: any, ...args: any[]) => {
      logs.push(`WRITE: ${filePath}`);
      return fs.writeFileSync(filePath, data, ...args);
    },
    unlinkSync: (filePath: string) => {
      logs.push(`DELETE: ${filePath}`);
      return fs.unlinkSync(filePath);
    }
  };
}

function analyzeFsLogs(fsLogs: string[], baseDir: string, allowedDir: string): { traversalAttempts: string[], successfulTraversals: string[] } {
  const traversalAttempts: string[] = [];
  const successfulTraversals: string[] = [];

  for (const entry of fsLogs) {
    const [operation, rawPath] = entry.split(': ').map(s => s.trim());
    const resolvedPath = path.resolve(baseDir, rawPath);

    if (!resolvedPath.startsWith(allowedDir)) {
      traversalAttempts.push(`${operation} ${resolvedPath}`);

      if (operation === 'READ' || operation === 'WRITE' || operation === 'DELETE') {
        successfulTraversals.push(`${operation} ${resolvedPath}`);
      }
    }
  }

  return { traversalAttempts, successfulTraversals };
}

export function runPathTraversalExploit(exploitCode: string): Result {
  
  const { baseDir, uploadsDir } = setupTraversalEnvironment();
  process.chdir(uploadsDir);

  const fsLogs: string[] = [];
  const spyFs = createFsSpy(fsLogs);

  const context = vm.createContext({ console, require, fs: spyFs, process });

  try {
    const script = new vm.Script(exploitCode);
    script.runInContext(context);
  } catch (e: any) {
    if (e instanceof SyntaxError) {
      return buildSyntaxErrorResult(exploitCode, e.message);
    }
    return buildRuntimeErrorResult(exploitCode, e.message);
  }

  const { traversalAttempts: _unused, successfulTraversals } = analyzeFsLogs(fsLogs, baseDir, uploadsDir);

  if (successfulTraversals.length > 0) {
    return buildExploitResult(exploitCode, `Successful path traversal operations: ${successfulTraversals.join(', ')}`);
  }

  return buildUnsuccessfulRun(exploitCode);
}
