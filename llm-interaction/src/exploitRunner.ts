// exploitRunner.ts
import fs from 'fs';
import path from 'path';
import os from 'os';
import {
    Result,
    buildExploitResult,
    buildSyntaxErrorResult,
    buildRuntimeErrorResult,
    buildUnsuccessfulRun,
} from './results';

import { execSync } from 'child_process';
import { Package } from './package';
import { runPackageSetup } from './util/runPackageSetup';
import { killProcessGroups } from './util/killProcessGroups';

/** Helper to list all files in a directory */
function listFiles(dir: string): Set<string> {
    return new Set(fs.readdirSync(dir));
}


/** Run a Code/Command Injection exploit and detect filesystem changes */
export function runInjectionExploit(exploitCode: string): Result {
    const initialCwd = process.cwd();
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'inj-test-'));
    process.chdir(tmpDir);

    const cwd = process.cwd();
    const exploitFile = path.join(cwd, "exploit.js");

    const before = listFiles(tmpDir);

    
    try {
        fs.writeFileSync(exploitFile, exploitCode, "utf-8");
        
        execSync(`node ${exploitFile}`, { stdio: "ignore" }); 
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            process.chdir(initialCwd);
            return buildSyntaxErrorResult(exploitCode, e.message);
        }
        process.chdir(initialCwd);
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = listFiles(tmpDir);
    const newFiles = [...after].filter(x => !before.has(x) && x.endsWith('.txt'));

    if (newFiles.length > 0) {
        process.chdir(initialCwd);
        return buildExploitResult(exploitCode, `New files created: ${newFiles.join(', ')}`);
    }
    process.chdir(initialCwd);
    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Prototype Pollution exploit and detect new prototype properties */
export function runPrototypePollutionExploit(exploitCode: string): Result {
    const initialCwd = process.cwd();
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'proto-poll-test-'));
    process.chdir(tmpDir);

    const cwd = process.cwd();
    const exploitFile = path.join(cwd, "exploit.js");
    const resultFile = path.join(cwd, "pollution_result.json");

    const wrappedCode = `
        const fs = require('fs');

        const beforeKeys = Reflect.ownKeys(Object.prototype);
        const beforeValues = new Map(beforeKeys.map(k => [k, Object.prototype[k]]));

        try {
            ${exploitCode}
        } catch (e) {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "runtime-error", message: e.message }));
            process.exit(0);
        }

        const afterKeys = Reflect.ownKeys(Object.prototype);
        const newKeys = afterKeys.filter(k => !beforeKeys.includes(k));
        const modifiedPrimitives = beforeKeys.filter(k =>
            typeof Object.prototype[k] !== 'object' &&
            typeof Object.prototype[k] !== 'function' &&
            Object.prototype[k] !== beforeValues.get(k)
        );

        if (newKeys.length > 0 || modifiedPrimitives.length > 0) {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "polluted", newKeys, modifiedPrimitives }));
        } else {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "clean" }));
        }
    `;

    try {
        fs.writeFileSync(exploitFile, wrappedCode, "utf-8");
        if (fs.existsSync(resultFile)) fs.unlinkSync(resultFile); // Clean stale result

        execSync(`node ${exploitFile}`, { stdio: "ignore" });

        if (!fs.existsSync(resultFile)) {
            process.chdir(initialCwd);
            return buildUnsuccessfulRun(exploitCode); // No result file? Probably clean
        }

        const resultRaw = fs.readFileSync(resultFile, "utf-8");
        const resultJson = JSON.parse(resultRaw);

        if (resultJson.type === "polluted") {
            process.chdir(initialCwd);
            return buildExploitResult(exploitCode, `Polluted keys: ${resultJson.newKeys.join(", ")}, Modified: ${resultJson.modifiedPrimitives.join(", ")}`);
        } else if (resultJson.type === "runtime-error") {
            process.chdir(initialCwd);
            return buildRuntimeErrorResult(exploitCode, resultJson.message);
        } else {
            process.chdir(initialCwd);
            return buildUnsuccessfulRun(exploitCode);
        }

    } catch (e: any) {
        process.chdir(initialCwd);
        return buildRuntimeErrorResult(exploitCode, e.message);
    } finally {
        try { fs.unlinkSync(exploitFile); } catch {}
        try { fs.unlinkSync(resultFile); } catch {}
    }
}

/** Run a Path Traversal exploit and detect successful traversals */
function listFilesRecursively(baseDir: string): Set<string> {
  const files = new Set<string>();
  function walk(dir: string) {
    for (const file of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        walk(fullPath);
      } else {
        files.add(path.relative(baseDir, fullPath));
      }
    }
  }
  walk(baseDir);
  return files;
}

function setupTraversalEnvironment(): { baseDir: string, uploadsDir: string } {
  const baseDir = fs.mkdtempSync(path.join(os.tmpdir(), 'path-traversal-test-'));
  const uploadsDir = path.join(baseDir, 'uploads');
  fs.mkdirSync(uploadsDir);
  return { baseDir, uploadsDir };
}


function analyzeFsLogs(fsLogs: string[], baseDir: string, allowedDir: string): { traversalAttempts: string[], successfulTraversals: string[] } {
  const traversalAttempts: string[] = [];
  const successfulTraversals: string[] = [];

  for (const entry of fsLogs) {
    const [operation, rawPath] = entry.split(': ').map(s => s.trim());
    const resolvedPath = path.resolve(baseDir, rawPath);

    if (!resolvedPath.startsWith(allowedDir)) {
      traversalAttempts.push(`${operation} ${resolvedPath}`);

      if (operation === 'READ' || operation === 'WRITE' || operation === 'DELETE') {
        successfulTraversals.push(`${operation} ${resolvedPath}`);
      }
    }
  }

  return { traversalAttempts, successfulTraversals };
}

export function runPathTraversalExploit(exploitCode: string, pkg: Package): Result {
  const initialCwd = process.cwd();
  const spyFsPath = path.resolve('../dist/spyFs.js'); 
  const { baseDir, uploadsDir } = setupTraversalEnvironment();
  process.chdir(uploadsDir);

  const cwd = process.cwd();
  const exploitFile = path.join(cwd, "exploit.js");

  const logFilePath = path.join(os.tmpdir(), `fslog-${Date.now()}.txt`);
  

  try {
    fs.writeFileSync(exploitFile, exploitCode, "utf-8");
    const pids: number[] = runPackageSetup(pkg,spyFsPath, logFilePath);

    if(pids.length === 0) { //No server running log fs calls in exploit
        execSync(`node --require ${spyFsPath} ${exploitFile}`, {
        stdio: 'ignore',
        env: {
          ...process.env,
          SPY_FS_LOG_PATH: logFilePath
         }
      });
    }else { // Server running log fs calls in server side ignore calls in exploit
        execSync(`node ${exploitFile}`, {
        stdio: 'ignore',
        env: {
          ...process.env,
          SPY_FS_LOG_PATH: logFilePath
       }
      });

    }

    killProcessGroups(pids);
  } catch (e: any) {
    if (e instanceof SyntaxError) {
      process.chdir(initialCwd);
      return buildSyntaxErrorResult(exploitCode, e.message);
    }
    process.chdir(initialCwd);
    return buildRuntimeErrorResult(exploitCode, e.message);
  }

  const fsLogs = fs.existsSync(logFilePath)
    ? fs.readFileSync(logFilePath, 'utf-8').trim().split('\n')
    : [];
  //console.log(fsLogs);
  const { traversalAttempts: _unused, successfulTraversals } = analyzeFsLogs(fsLogs, baseDir, uploadsDir);

  if (successfulTraversals.length > 0) {
    process.chdir(initialCwd);
    return buildExploitResult(exploitCode, `Successful path traversal operations: ${successfulTraversals.join(', ')}`);
  }
  process.chdir(initialCwd);
  return buildUnsuccessfulRun(exploitCode);
}
