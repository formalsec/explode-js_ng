// exploitRunner.ts

import fs from 'fs';
import path from 'path';
import os from 'os';
import vm from 'vm';
import {
    Result,
    buildExploitResult,
    buildSyntaxErrorResult,
    buildRuntimeErrorResult,
    buildUnsuccessfulRun,
} from './results';

/** Helper to list all files in a directory */
function listFiles(dir: string): Set<string> {
    return new Set(fs.readdirSync(dir));
}

/** Helper to list all keys on Object.prototype */
function getPrototypeKeys(): Set<string | symbol> {
    return new Set(Reflect.ownKeys(Object.prototype));
}

/** Clean up Object.prototype by deleting polluted properties */

function restoreObjectPrototype(original: Record<string | symbol, any>): void {
    const target = Object.prototype;

    // Restore original values
    for (const key of Reflect.ownKeys(original)) {
        try {
            (target as any)[key] = original[key];
        } catch { /* ignore read-only properties */ }
    }

    // Remove polluted keys (those not in original)
    for (const key of Reflect.ownKeys(target)) {
        if (!(key in original)) {
            try {
                delete (target as any)[key];
            } catch { /* ignore non-configurable properties */ }
        }
    }
}
/** Run a Code/Command Injection exploit and detect filesystem changes */
export function runInjectionExploit(exploitCode: string): Result {
    
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'exploit-test-'));
    process.chdir(tmpDir);

    const before = listFiles(tmpDir);

    const context = vm.createContext({
        console,
        require,
        __dirname: tmpDir
    });

    try {
        const script = new vm.Script(exploitCode);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(exploitCode, e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = listFiles(tmpDir);
    const newFiles = [...after].filter(x => !before.has(x) && x.endsWith('.txt'));

    if (newFiles.length > 0) {
        return buildExploitResult(exploitCode, `New files created: ${newFiles.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Prototype Pollution exploit and detect new prototype properties */
function cloneObjectPrototype(): Record<string | symbol, any> {
    const clone: Record<string | symbol, any> = {};
    for (const key of Reflect.ownKeys(Object.prototype)) {
        const val = (Object.prototype as any)[key];
        if (typeof val === 'object' || typeof val === 'function') {
            // Shallow copy to avoid reference pollution
            clone[key] = null; // Skip checking value, just presence
        } else {
            clone[key] = val;
        }
    }
    return clone;
}


export function runPrototypePollutionExploit(exploitCode: string): Result {
    //  Create a fake prototype to observe pollution
    const fakePrototype: Record<string | symbol, any> = {};

    //  Create a fake Object constructor that uses the fake prototype
    function FakeObject() {}
    FakeObject.prototype = fakePrototype;

    // Snapshot the keys and values before running the exploit
    const beforeKeys = new Set(Reflect.ownKeys(fakePrototype));
    const beforeValues = new Map(
        [...beforeKeys].map(key => [key, fakePrototype[key]])
    );

    //  Build context with FakeObject as the global Object
    const context = vm.createContext({
        console,
        require,
        Object: FakeObject,
        defineProperty: Object.defineProperty,
        getPrototypeOf: Object.getPrototypeOf,
    });

    try {
        const script = new vm.Script(exploitCode);
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) return buildSyntaxErrorResult(exploitCode, e.message);
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    // After execution, check what changed
    const afterKeys = new Set(Reflect.ownKeys(fakePrototype));
    const newKeys = [...afterKeys].filter(k => !beforeKeys.has(k));
    const modifiedPrimitives = [...beforeKeys].filter(k =>
        typeof fakePrototype[k] !== 'object' &&
        typeof fakePrototype[k] !== 'function' &&
        fakePrototype[k] !== beforeValues.get(k)
    );

    if (newKeys.length > 0 || modifiedPrimitives.length > 0) {
        return buildExploitResult(
            exploitCode,
            `Polluted prototype keys: ${newKeys.join(', ')}, modified: ${modifiedPrimitives.join(', ')}`
        );
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Path Traversal exploit and detect successful traversals */
function listFilesRecursively(baseDir: string): Set<string> {
  const files = new Set<string>();
  function walk(dir: string) {
    for (const file of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        walk(fullPath);
      } else {
        files.add(path.relative(baseDir, fullPath));
      }
    }
  }
  walk(baseDir);
  return files;
}

function setupTraversalEnvironment(): { baseDir: string, uploadsDir: string } {
  const baseDir = fs.mkdtempSync(path.join(os.tmpdir(), 'path-traversal-test-'));
  const uploadsDir = path.join(baseDir, 'uploads');
  fs.mkdirSync(uploadsDir);
  return { baseDir, uploadsDir };
}

function createFsSpy(logs: string[]): any {
  return {
    ...fs,
    readFileSync: (filePath: string, ...args: any[]) => {
      logs.push(`READ: ${filePath}`);
      return fs.readFileSync(filePath, ...args);
    },
    writeFileSync: (filePath: string, data: any, ...args: any[]) => {
      logs.push(`WRITE: ${filePath}`);
      return fs.writeFileSync(filePath, data, ...args);
    },
    unlinkSync: (filePath: string) => {
      logs.push(`DELETE: ${filePath}`);
      return fs.unlinkSync(filePath);
    }
  };
}

function analyzeFsLogs(fsLogs: string[], baseDir: string, allowedDir: string): { traversalAttempts: string[], successfulTraversals: string[] } {
  const traversalAttempts: string[] = [];
  const successfulTraversals: string[] = [];

  for (const entry of fsLogs) {
    const [operation, rawPath] = entry.split(': ').map(s => s.trim());
    const resolvedPath = path.resolve(baseDir, rawPath);

    if (!resolvedPath.startsWith(allowedDir)) {
      traversalAttempts.push(`${operation} ${resolvedPath}`);

      if (operation === 'READ' || operation === 'WRITE' || operation === 'DELETE') {
        successfulTraversals.push(`${operation} ${resolvedPath}`);
      }
    }
  }

  return { traversalAttempts, successfulTraversals };
}

export function runPathTraversalExploit(exploitCode: string): Result {
  
  const { baseDir, uploadsDir } = setupTraversalEnvironment();
  process.chdir(uploadsDir);

  const fsLogs: string[] = [];
  const spyFs = createFsSpy(fsLogs);

  const context = vm.createContext({ console, require, fs: spyFs, process });

  try {
    const script = new vm.Script(exploitCode);
    script.runInContext(context);
  } catch (e: any) {
    if (e instanceof SyntaxError) {
      return buildSyntaxErrorResult(exploitCode, e.message);
    }
    return buildRuntimeErrorResult(exploitCode, e.message);
  }

  const { traversalAttempts: _unused, successfulTraversals } = analyzeFsLogs(fsLogs, baseDir, uploadsDir);

  if (successfulTraversals.length > 0) {
    return buildExploitResult(exploitCode, `Successful path traversal operations: ${successfulTraversals.join(', ')}`);
  }

  return buildUnsuccessfulRun(exploitCode);
}
