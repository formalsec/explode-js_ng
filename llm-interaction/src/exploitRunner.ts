// exploitRunner.ts
import { NodeVM } from 'vm2';
import fs from 'fs';
import path from 'path';
import os from 'os';
import vm from 'vm';
import {
    Result,
    buildExploitResult,
    buildSyntaxErrorResult,
    buildRuntimeErrorResult,
    buildUnsuccessfulRun,
} from './results';

import { execSync } from 'child_process';

/** Helper to list all files in a directory */
function listFiles(dir: string): Set<string> {
    return new Set(fs.readdirSync(dir));
}


/** Run a Code/Command Injection exploit and detect filesystem changes */
export function runInjectionExploit(exploitCode: string): Result {
    
    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'exploit-test-'));
    process.chdir(tmpDir);

    const before = listFiles(tmpDir);

    const context = vm.createContext({
        console,
        require,
        __dirname: tmpDir
    });

    try {
        const script = new vm.Script(exploitCode, "exploit.js");
        script.runInContext(context);
    } catch (e: any) {
        if (e instanceof SyntaxError) {
            return buildSyntaxErrorResult(exploitCode, e.message);
        }
        return buildRuntimeErrorResult(exploitCode, e.message);
    }

    const after = listFiles(tmpDir);
    const newFiles = [...after].filter(x => !before.has(x) && x.endsWith('.txt'));

    if (newFiles.length > 0) {
        return buildExploitResult(exploitCode, `New files created: ${newFiles.join(', ')}`);
    }

    return buildUnsuccessfulRun(exploitCode);
}

/** Run a Prototype Pollution exploit and detect new prototype properties */
/** Take a safe snapshot of Object.prototype's keys and primitive values */
function clonePrototypeSnapshot(): Map<string | symbol, any> {
  const snapshot = new Map<string | symbol, any>();
  for (const key of Reflect.ownKeys(Object.prototype)) {
    const val = (Object.prototype as any)[key];
    if (typeof val === 'object' || typeof val === 'function') {
      snapshot.set(key, null); // Ignore deep references
    } else {
      snapshot.set(key, val); // Store primitive
    }
  }
  return snapshot;
}

/** Compare snapshot to current Object.prototype state */
function restorePrototypeFromSnapshot(snapshot: Map<string | symbol, any>): void {
  const currentKeys = new Set(Reflect.ownKeys(Object.prototype));

  // Restore original values
  for (const [key, value] of snapshot.entries()) {
    try {
      (Object.prototype as any)[key] = value;
    } catch { /* read-only or non-configurable, skip */ }
  }

  // Remove keys that didnâ€™t exist before
  for (const key of currentKeys) {
    if (!snapshot.has(key)) {
      try {
        delete (Object.prototype as any)[key];
      } catch { /* non-configurable, skip */ }
    }
  }
}

function analyzePrototypeChanges(before: Map<string | symbol, any>): {
  newKeys: (string | symbol)[];
  modified: (string | symbol)[];
} {
  const afterKeys = new Set(Reflect.ownKeys(Object.prototype));
  const newKeys: (string | symbol)[] = [];
  const modified: (string | symbol)[] = [];

  for (const key of afterKeys) {
    if (!before.has(key)) {
      newKeys.push(key);
    } else {
      const afterVal = (Object.prototype as any)[key];
      const beforeVal = before.get(key);
      if (
        typeof afterVal !== 'object' &&
        typeof afterVal !== 'function' &&
        afterVal !== beforeVal
      ) {
        modified.push(key);
      }
    }
  }

  return { newKeys, modified };
}



export function runPrototypePollutionExploit(exploitCode: string): Result {
    const cwd = process.cwd();
    const exploitFile = path.join(cwd, "exploit.js");
    const resultFile = path.join(cwd, "pollution_result.json");

    const wrappedCode = `
        const fs = require('fs');

        const beforeKeys = Reflect.ownKeys(Object.prototype);
        const beforeValues = new Map(beforeKeys.map(k => [k, Object.prototype[k]]));

        try {
            ${exploitCode}
        } catch (e) {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "runtime-error", message: e.message }));
            process.exit(0);
        }

        const afterKeys = Reflect.ownKeys(Object.prototype);
        const newKeys = afterKeys.filter(k => !beforeKeys.includes(k));
        const modifiedPrimitives = beforeKeys.filter(k =>
            typeof Object.prototype[k] !== 'object' &&
            typeof Object.prototype[k] !== 'function' &&
            Object.prototype[k] !== beforeValues.get(k)
        );

        if (newKeys.length > 0 || modifiedPrimitives.length > 0) {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "polluted", newKeys, modifiedPrimitives }));
        } else {
            fs.writeFileSync("${resultFile}", JSON.stringify({ type: "clean" }));
        }
    `;

    try {
        fs.writeFileSync(exploitFile, wrappedCode, "utf-8");
        if (fs.existsSync(resultFile)) fs.unlinkSync(resultFile); // Clean stale result

        execSync(`node ${exploitFile}`, { stdio: "ignore" });

        if (!fs.existsSync(resultFile)) {
            return buildUnsuccessfulRun(exploitCode); // No result file? Probably clean
        }

        const resultRaw = fs.readFileSync(resultFile, "utf-8");
        const resultJson = JSON.parse(resultRaw);

        if (resultJson.type === "polluted") {
            return buildExploitResult(exploitCode, `Polluted keys: ${resultJson.newKeys.join(", ")}, Modified: ${resultJson.modifiedPrimitives.join(", ")}`);
        } else if (resultJson.type === "runtime-error") {
            return buildRuntimeErrorResult(exploitCode, resultJson.message);
        } else {
            return buildUnsuccessfulRun(exploitCode);
        }

    } catch (e: any) {
        return buildRuntimeErrorResult(exploitCode, e.message);
    } finally {
        try { fs.unlinkSync(exploitFile); } catch {}
        try { fs.unlinkSync(resultFile); } catch {}
    }
}

/** Run a Path Traversal exploit and detect successful traversals */
function listFilesRecursively(baseDir: string): Set<string> {
  const files = new Set<string>();
  function walk(dir: string) {
    for (const file of fs.readdirSync(dir)) {
      const fullPath = path.join(dir, file);
      if (fs.statSync(fullPath).isDirectory()) {
        walk(fullPath);
      } else {
        files.add(path.relative(baseDir, fullPath));
      }
    }
  }
  walk(baseDir);
  return files;
}

function setupTraversalEnvironment(): { baseDir: string, uploadsDir: string } {
  const baseDir = fs.mkdtempSync(path.join(os.tmpdir(), 'path-traversal-test-'));
  const uploadsDir = path.join(baseDir, 'uploads');
  fs.mkdirSync(uploadsDir);
  return { baseDir, uploadsDir };
}

function createFsSpy(logs: string[]): any {
  return {
    ...fs,
    readFileSync: (filePath: string, ...args: any[]) => {
      logs.push(`READ: ${filePath}`);
      return fs.readFileSync(filePath, ...args);
    },
    writeFileSync: (filePath: string, data: any, ...args: any[]) => {
      logs.push(`WRITE: ${filePath}`);
      return fs.writeFileSync(filePath, data, ...args);
    },
    unlinkSync: (filePath: string) => {
      logs.push(`DELETE: ${filePath}`);
      return fs.unlinkSync(filePath);
    }
  };
}

function analyzeFsLogs(fsLogs: string[], baseDir: string, allowedDir: string): { traversalAttempts: string[], successfulTraversals: string[] } {
  const traversalAttempts: string[] = [];
  const successfulTraversals: string[] = [];

  for (const entry of fsLogs) {
    const [operation, rawPath] = entry.split(': ').map(s => s.trim());
    const resolvedPath = path.resolve(baseDir, rawPath);

    if (!resolvedPath.startsWith(allowedDir)) {
      traversalAttempts.push(`${operation} ${resolvedPath}`);

      if (operation === 'READ' || operation === 'WRITE' || operation === 'DELETE') {
        successfulTraversals.push(`${operation} ${resolvedPath}`);
      }
    }
  }

  return { traversalAttempts, successfulTraversals };
}

export function runPathTraversalExploit(exploitCode: string): Result {
  
  const { baseDir, uploadsDir } = setupTraversalEnvironment();
  process.chdir(uploadsDir);

  const fsLogs: string[] = [];
  const spyFs = createFsSpy(fsLogs);

  const context = vm.createContext({ console, require, fs: spyFs, process });

  try {
    const script = new vm.Script(exploitCode);
    script.runInContext(context);
  } catch (e: any) {
    if (e instanceof SyntaxError) {
      return buildSyntaxErrorResult(exploitCode, e.message);
    }
    return buildRuntimeErrorResult(exploitCode, e.message);
  }

  const { traversalAttempts: _unused, successfulTraversals } = analyzeFsLogs(fsLogs, baseDir, uploadsDir);

  if (successfulTraversals.length > 0) {
    return buildExploitResult(exploitCode, `Successful path traversal operations: ${successfulTraversals.join(', ')}`);
  }

  return buildUnsuccessfulRun(exploitCode);
}
